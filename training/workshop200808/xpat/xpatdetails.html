<html>
  <head>
    <title>XPat Details</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <link rel="stylesheet" href="../styles.css" type="TEXT/CSS">
  </head>
  <body bgcolor="#FFFFFF" leftmargin="10" topmargin="10" marginwidth="10" marginheight="10" class="mainpalette">
    <h1><a name="top"></a>XPAT Details</h1>
    <p>Indexing TextClass and FindaidClass data will be covered in detail during the <a href="../textclass/tcoutline.html">Text
        Class Data Preparation</a> and <a href="../findaidclass/fcoutline.html">FindaidClass Data Preparation</a> sections.</p>
    <ul>
      <li><a href="#xpatconfig"><b>Collmgr and System Configuration for XPAT </b></a>
        <ul>
          <li><a href="#xpatcollmgr">Collmgr fields</a> </li>
          <li><a href="#xpattrouble">Troubleshooting</a> </li>
        </ul>
      </li>
      <li><a href="#textindexing"><b>Discussion of Text Indexing and Region indexing</b></a>
        <ul>
          <li>XPAT has evolved from OpenText's pat50 indexing and search engine.</li>
          <li><a href="#sistrings">Semi-infinite strings</a></li>
          <li><a href="#characters">Characters, Unicode, Tools</a></li>
          <li><a href="#datadict">Indexing and the Data Dictionary</a></li>
          <li><a href="#regions">Regions</a></li>
        </ul>
      </li>
      <li> <b><a href="#syntax">Query Language Syntax</a></b>
        <ul>
          <li><a href="#Invoking">Invoking XPAT</a></li>
          <li><a href="#points">Identifying Points</a></li>
          <li><a href="#Regions">Identifying Regions</a></li>
          <li><a href="#sets">Identifying Sets</a></li>
          <li><a href="#viewing">Viewing Sets</a></li>
          <li><a href="#UsingOps">Using Operators</a></li>
        </ul>
      </li>
      <li><b><a href="#fabricatedregions">Introduction to fabricated regions</a></b>
        <ul>
          <li><a href="#DebugQuery">Debugging Complex Queries</a></li>
        </ul>
      </li>
        
      <li><b><a href="#additional">Additional Details</a></b> (not covered explicitly
        during the workshop)</li>
    </ul>
    
    <p>A full list of XPAT commands can be found at: <a href="http://quod.lib.umich.edu/sgml/pat/pat50manual.html" target="external">http://quod.lib.umich.edu/sgml/pat/pat50manual.html</a></p>
    <hr width="50%"> 
      
      
      <h3><a name="xpatconfig"></a>Collmgr and System Configuration for XPAT</h3>
      
      <h4><a name="xpatcollmgr"></a> <span class="sectionheader">Collmgr fields</span></h4>
      <p>To invoke collmgr: <a href="http://______.ws.umdl.umich.edu/cgi/c/collmgr/collmgr" target="external">http://______.ws.umdl.umich.edu/cgi/c/collmgr/collmgr</a> (replace <b>______</b> with you account user id.
        <ul>
          <li>The <b>locale</b> field: en_US.UTF-8 </li>
          <li>The <b>host</b> and <b>devhost</b> fields.  Must match the virtual host for local data otherwise dlxsd daemon connection is attepmted on a remote machine.</li>
          <li>The <b>dd</b> field specifies the location for the data dictionary or dictionaries.</li>
        </ul>
        
        <h4><a name="xpattrouble"></a> <span class="sectionheader">Troubleshooting</span></h4>
        <ul>
          <li>XPAT debug switch: <b><tt>;debug=xpat</tt></b>, e.g.  <a href="http://______.ws.umdl.umich.edu/cgi/t/text/text-idx?c=sampletc_utf8;type=simple;rgn=full+text;debug=xpat;q1=dog" target="external">TextClass</a></li>
          <li>Note also <b><tt>$DLXSROOT/bin/symlinks/xpatu</tt> -> "the location of your xpatu binary"</b></li>
        </ul>
      </p>
      
      
      <h3><a name="textindexing"></a>Discussion of Text Indexing and Region indexing</h3>
      
      <h4><a name="sistrings"></a> <span class="sectionheader">Semi-infinite strings</span></h4>
      <p>XPAT indexes strings (semi-infinite strings) rather than words. Consider this text:<blockquote><pre>
... called Kitchee-Gumeeng, also great lake. The
words Mitchee and Kitchee both seem to mean
the <b>same thing, great,</b> large; whether there is a
shade of difference in applying ...</pre></blockquote>
        
        Searching for <b>same thing great</b> will retrieve the string beginning with "same" and followed by "thing great".  However searching for  <b>same great</b> will not retrieve anything.  XPAT searches for strings, anchored at index points that match up to virtually the end of the document. </p>
      <p>Index points are offsets into the text where XPAT looks for matches.  Generally, index points are characters following spaces.</p>
      
      <p> Ssearching for several words with XPAT is implicitly a phrase search.  To search for "same" AND/OR "great" requires the use of boolean operators (^ and +) and <b>regions</b>. </p>
      
      <p>XPAT compresses multiple spaces in the text to a single space when indexing and searching. </p>
      <p>XPAT also can perform case mapping and character mapping.  This is specified in the data dictionary <tt>(.dd)</tt> file.</p>
      
      <!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back
          to top</i></a> <!-- #EndLibraryItem --></i> 
      
      <hr width="25%">
        
        <h4><a name="characters"></a> <span class="sectionheader">Characters, Unicode, Tools</span></h4>
        
        <p>This section treats issues of character encoding as it applies to XPAT and mentions a few tools we've written you may find useful.  There is also and <a href="../unicode/unicode.html">expanded treatment</a> of this subject.</p>
        <p>Some Unicode / XPAT facts:
          <ul>
            <li>The ISO-8859-* (e.g. Latin-1) encodings support 256 characters but only one set of 256 characters at a time.  Unicode is a uniform standard to support virtually all historical and contemporay alphabets.</li>  
            <li>Unicode assigns a number to each character.</li>
            <li>UTF-8 is a multi-byte variable length encoding of that number. </li>
            <li>A byte is not a character, except for code points 0 to 127. </li>
            <li>ASCII is UTF-8 by design. If you have ASCII, you have UTF-8.</li>
            <li>XPAT supports indexing/searcing the Basic Multilingual Plane (Plane 0) which contains 65536 characters. The plane is divided into blocks of varying size by alphabet.</li>
          </ul>
        </p>
        <p>There are many reasons to use Unicode.
          <ul>
            <li>Can represent more than one alphabet in a single document or web page.</li>
            <li>Searchable. Character entities are not needed. </li>
            <li>Programming is simpler.</li>
            
            <li>Users can enter unaccented characters and get results for accented Latin characters via XPAT mapping functionality.</li>
            <li>Non-ASCII characters can be entered by users via national keyboards, virtual keyboards, IMEs, copy/paste.</li>
            <li>Can be collated.</li>
            <li>Fundamental to XML.</li>
          </ul>
        </p>
        
        <p>We deliver a few locally developed tools you may find useful.
          <ul>
            <li><tt>$DLXSROOT/bin/t/text/isocer2utf8</tt></li>
            <li><tt>$DLXSROOT/bin/t/text/ncr2utf8</tt></li>
            <li><tt>$DLXSROOT/bin/t/text/utf8chars</tt></li>
            <li><tt>xpatutf8check</tt></li>
            <li><a href="http://hul.harvard.edu/jhove/distribution.html" target="external">JHOVE</a> <tt>jhove -c /l/local/jhove/conf/jhove.conf -m utf8-hul</tt></li>
          </ul>  
        </p>
        
        <!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back
            to top</i></a> <!-- #EndLibraryItem --></i> 
        
        <hr width="25%">
          
        <h4><a name="datadict"></a> <span class="sectionheader">Indexing and the Data Dictionary</span></h4>
          
          <p>This section applies only to XPAT-based classes: TextClass, FindaidClass. ImageClass is MySQL-based.  More when we talk about data preparation for the classes more fully.</p>
          
          <ul>
            <li>We use <tt><b>xpatbldu</b></tt>, <tt><b>xpatu</b></tt> and <tt><b>xmlrgn</b></tt> to index UTF-8 encoded XML data. </li>
            <li>Note: <tt>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</tt>  Important for <tt>xmlrgn</tt> </li>
          </ul>
          
          <ul>
            <li><tt><b>xpatbldu</b></tt> creates the main point index <b><tt><i>collid</i>.idx</tt></b></li>
            <li><tt><b>xmlrgn</b></tt> creates the main region index <b><tt><i>collid</i>0.rgn</tt></b>.  It parses the XML according to the DTD and indexes every element present in the XML.</li> 
            <li>Certain complex regions are indexed by sending a query for the region to <tt><b>xpatu</b></tt> with the <b><tt><font color="red">{export}</font></tt></b> command that creates a <font color="red"><b><tt>.rgn</tt></b></font> file named in the command. There will be several of these.</li>
          </ul>
          
          <p>Here's a look at the resulting files:
            
            <blockquote>
              <pre><tt>ls -al /l1/workshop/pfarber/dlxs/idx/s/sampletc_utf8 
                  
-rw-rw-r--  1 pfarber  dlps    816 Jun 16  2005 div1head.rgn
-rw-rw-r--  1 pfarber  dlps    576 Jun 16  2005 div2head.rgn
-rw-rw-r--  1 pfarber  dlps    528 Jun 16  2005 <b><font color="red">id.rgn</font></b>
-rw-rw-r--  1 pfarber  dlps    528 Jun 16  2005 mainauthor.rgn
-rw-rw-r--  1 pfarber  dlps    528 Jun 16  2005 maindate.rgn
-rw-rw-r--  1 pfarber  dlps    528 Jun 16  2005 mainheader.rgn
-rw-rw-r--  1 pfarber  dlps    528 Jun 16  2005 main.rgn
-rw-rw-r--  1 pfarber  dlps    528 Jun 16  2005 maintitle.rgn
-rw-rw-r--  1 pfarber  dlps   6704 Apr  4  2007 page.rgn
-rw-rw-r--  1 pfarber  dlps   6704 Apr  4  2007 page-t.rgn
-rw-rw-r--  1 pfarber  dlps 138040 Jun 16  2005 <b>sampletc_utf80.rgn</b>
-rw-rw-r--  1 pfarber  dlps  50907 Apr  5  2007 <b><font color="blue">sampletc_utf8.dd</font></b>
-rw-rw-r--  1 pfarber  dlps 968452 Apr  4  2007 <b>sampletc_utf8.idx</b>
-rw-rw-r--  1 pfarber  dlps      0 Jan 30  2004 sampletc_utf8.init
              </tt></pre>
          </blockquote>
          </p>

          <p>The <b><font color="blue">data dictionary</font></b> is an XML file in a collection subdirectory of the <b>idx</b> directory. It ties all the the index files together and holds the specifications for index points and character mappings.</p>

          <p>Here's a bit of the section of the data dictionary that specifies the index points, i.e. the points in your data where XPAT will look for matches to your query string:</p>

          <blockquote>
            <pre>            &lt;IndexPoints&gt;
            &lt;IndexPt&gt; &amp;printable.&lt;/IndexPt&gt;
            &lt;IndexPt&gt;&amp;printable.-&lt;/IndexPt&gt;
            &lt;IndexPt&gt;-&amp;printable.&lt;/IndexPt&gt;

            &lt;IndexPt&gt; &amp;Latin.&lt;/IndexPt&gt;
            &lt;IndexPt&gt;&amp;Latin.-&lt;/IndexPt&gt;
            &lt;IndexPt&gt;-&amp;Latin.&lt;/IndexPt&gt;

            &lt;IndexPt&gt; &amp;Greek.&lt;/IndexPt&gt;
            &lt;IndexPt&gt;&amp;Greek.-&lt;/IndexPt&gt;
            &lt;IndexPt&gt;-&amp;Greek.&lt;/IndexPt&gt;
            &lt;/IndexPoints&gt;
            </pre>

          </blockquote>
        
          <p>Note the metacharacters like <tt>&amp;printable., &amp;amp.</tt> or <tt>&amp;Greek.</tt> that represent all characters from one of the blocks of Unicode Plane 0. Index point metacharacters are based on the <a target="external" href="http://www.unicode.org/Public/UNIDATA/Blocks.txt">Unicode block definitions</a>, Perl unicode lib (e.g. <a target="external" href="../unicode/Latin.txt">lib/5.8.3/unicore/lib/Latin.pl</a>) and modified as described in the <a target="external" href="http://www.dlxs.org/docs/13/xpat/datadict.html#sec1.4.2">XPAT data dictionary document</a>.</p>
       
          <p>Here's a bit of the section of the data dictionary where character mapping is specified.  Refer to the <a target="external" href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">Unicode character database</a>.   This is mainly used for upper to lower case mapping for alphabets that have case.</p>

          <blockquote>
            <pre>            ...

            &lt;Map>&lt;From>!&lt;/From>&lt;To> &lt;/To>&lt;/Map>
            &lt;Map>&lt;From>"&lt;/From>&lt;To> &lt;/To>&lt;/Map>
            &lt;Map>&lt;From>$&lt;/From>&lt;To> &lt;/To>&lt;/Map>
            &lt;Map>&lt;From>%&lt;/From>&lt;To> &lt;/To>&lt;/Map>
                             ...
            &lt;Map&gt;&lt;From&gt;U+0391&lt;/From&gt;&lt;To&gt;U+03B1&lt;/To&gt;&lt;/Map&gt;

            &lt;Map&gt;&lt;From&gt;U+0392&lt;/From&gt;&lt;To&gt;U+03B2&lt;/To&gt;&lt;/Map&gt;
            &lt;Map&gt;&lt;From&gt;U+0393&lt;/From&gt;&lt;To&gt;U+03B3&lt;/To&gt;&lt;/Map&gt;

            &lt;Map&gt;&lt;From&gt;U+0394&lt;/From&gt;&lt;To&gt;U+03B4&lt;/To&gt;&lt;/Map&gt;
            &lt;Map&gt;&lt;From&gt;U+0395&lt;/From&gt;&lt;To&gt;U+03B5&lt;/To&gt;&lt;/Map&gt;

            ...
            </pre>
          </blockquote>

          <p>Finally here's an <a href="sampledatadict.html" target="external">example of a full data doctionary</a>.</p>

          <!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back
              to top</i></a> <!-- #EndLibraryItem --></i> 
          
          <hr width="25%">

          <h4><a name="regions"></a> <span class="sectionheader">Regions</span></h4>

            <p>XPAT indexes XML regions (via <tt><b>xmlrgn</b></tt>), allowing searching of text within regions, regions including text or other regions, etc.  Consider this diagram of the kind of regions XPAT can index.</p>

<blockquote><pre>
|&lt;------------------------- region FAMNAME --------------------------->|
|                                                                      |
<b>&lt;FAMNAME SOURCE="lcnaf" ENCODINGANALOG="100">Whittemore Family&lt;/FAMNAME></b>
|               |     |                     |          
|             ->|     |&lt;- region "A-SOURCE" |
|                                           |
|&lt;------------ region "FAMNAME-T" --------->|
</pre></blockquote>

            <p>There are three kinds of regions:

              <ol>
                <li><b>region FAMNAME</b> - Everything between the beginning and end of a tag pair, including the tags</li>
                <li><b>region "A-SOURCE"</b> -  The value of an XML attribute </li>
                <li><b>region "FAMNAME-T"</b> -  The contents of the begin tag </li>
              </ol>
            </p>

            <!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back
                to top</i></a> <!-- #EndLibraryItem --></i> 

            <hr width="25%">

      <h3><a name="syntax"></a>Query Language Syntax</h3>

              <h4><a name="Invoking"></a> <span class="sectionheader">Invoking XPAT</span></h4>
              <p>To start an interactive session with XPAT, enter <span class="unixcommand">xpatu</span> (for UTF-8 data indexing/searching) along with the name of the data dictionary (dd) file.: </p>

              <blockquote><b><code class="unixcommand">%
                          xpatu $DLXSROOT/idx/s/sampletc_utf8/sampletc_utf8.dd</code></b></blockquote>

              <!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back to top</i></a> <!-- #EndLibraryItem --></i> 

              <hr width="25%"> 

                <h4><a name="points"></a><span class="sectionheader">Identifying Points</span></h4>
                <p>In XPAT, a <i>point</i> is a unique byte offset in the full text where XPAT has indexed a string. Enter a string or byte offset in square brackets and set of points is returned: </p>

<blockquote> <pre> >> <span class="unixcommand">"prince"</span>
1: 134 matches

>> <span class="unixcommand">"prince "</span>
2: 123 matches

>> <span class="unixcommand">sample</span>
3: 10 matches

>> <span class="unixcommand">pr</span>
 539939, ..was said that Prince Alexander of Battenberg had changed into a ..
 957348, ..e only child, Prince Alexander, who came in before we went to ta..
1390470, ..TEM>Bismarck, Prince, and the Austro-German alliance ~ &lt;REF&gt;xxiv..
 552103, ..alliance that Prince Bismarck, in 1879, entered into the very cl..
 208247, .. sceptre d'un prince de religion orthodoxe.&lt;/P&gt; &lt;P&gt; &lt;..
1016444, ..n the streets Prince Michael and Teresia, 20 to 30 dinars toward..
 943446, ..ian statue of Prince Michael, whose name and portrait are found ..
 483031, ..la volont&eacute; du prince Nicolas, ses r&eacute;solutions personnelles au su..
1411801, ..udolph, Crown Prince, Popularity of ~ &lt;REF&gt;69&lt;/REF&gt; &lt;/ITEM..
1141121, ..raged it. The Prince suspected nothing of what was taking place ..

>> <span class="unixcommand">"emile "</span>
4 : 9 matches

>> <span class="unixcommand">"Émile "</span>
5 : 9 matches

>> <span class="unixcommand">[290947]</span>
6 : one match
                  </pre> 
        </blockquote>

                <p>The first query finds all "semi-infinite strings" that begin with "prince", the second finds those that are "prince" exactly (with the space, or anything that has been mapped to a space).  The "Emile" queries demonstrate character mapping and case mapping. The last, finds the string beginning at the byte offset 290947. </p>

                <!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back to top</i></a> <!-- #EndLibraryItem -->

                <hr width="25%">

  <h4> <a name="Regions"></a><span class="sectionheader">Identifying Regions</span></h4>

                  <p>A region in XPAT is a span of text comprising zero or more bytes. <span class="unixcommand">xmlrgn</span> or <tt class="unixcommand">multirgn </tt>(discussed in the <a href="../textclass/tcoutline.html#TextClassIndexBuildingwithXPAT">TextClass Collection Implementation/Indexing Section</a>) handles the creation of these regions.</p>

  <p>To find how many of a particular region type exist, enter <tt>region</tt> plus the name of the region (double quotes are needed if the name contains non-alphanumeric characters). 

<blockquote> <pre><code>>> <span class="unixcommand">region "DIV1"</span>
1: 38 matches
>> <span class="unixcommand">region "A-NODE" </span>
2: 46 matches</code></pre></blockquote>
</p>

<p>Also see the <code> <a href="#ddinfo">{ddinfo regionnames}</a></code> command.<br>
   Also see the <code><a href="#history">history</a></code> command. </p>

<!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back to top</i></a> <!-- #EndLibraryItem --> 

                  <hr width="25%"> 

<h4> <a name="sets"></a>Identifying Sets (Named Sets)</h4>

<p>Any collection of points or regions can be grouped together in a <i>set</i>. Sets can be combined or split with XPAT's boolean operators. All sets created during a session have unique number identifier They can be can given names (<i>name</i> = ). They can be printed out (<b>pr</b>), saved, exported (useful in the creation of <a href="fabregions.html">"fabricated regions"</a>). Here are just a few examples: </p>

<blockquote> <pre><code>&gt;&gt;&nbsp;<span class="unixcommand">long</span>
1: 244 matches

&gt;&gt;&nbsp;<span class="unixcommand">help</span>
2: 54 matches

&gt;&gt;&nbsp;<span class="unixcommand">1 + 2</span>
3: 298 matches

&gt;&gt; <span class="unixcommand">"alternate"</span> 
4: 5 matches

&gt;&gt; <span class="unixcommand">pr 4</span>
1175485, ..most from the alternate advance and retreat of the Russian and T..
1165090, ..in. Vineyards alternated with fields of barley, oats, and maize;..
 967310, ..men and women alternately; &lt;EPB/&gt; &lt;PB REF="00000208.tif" S..
1313659, ..a and Austria alternately. But, when able to repel aggression, s..
1303571, .. each country alternately. It should be composed of three secti..

&gt;&gt; <b><span class="unixcommand">mysearch</span></b><span class="unixcommand"> = "pair"</span>
5: mysearch = 3 matches

&gt;&gt; <b class="unixcommand">pr *mysearch</b>
1170568, ..and a half; a pair of buffaloes, 600 francs (£24).&lt;/P&gt; &lt;P&gt;B..
 848085, ..s dress was a pair of large Turkish trousers of white wool, a sh..
1085132, ..nd thick; two pairs of oxen drew it by means of a pole which was.. </code></pre></blockquote>

<p>Also see the <code><a href="#subset">subset </a></code> command.<br>
   Also see the <a href="#sortorder"><code>{sortorder}</code></a> setting.<br>
   Also see other <a href="#Operators">operators and relations</a>.</p>

<!-- #BeginLibraryItem "/Library/back to top.lbi" -->
<a href="#top"><i>Back to top</i></a> 
<!-- #EndLibraryItem --> 

<hr width="25%"> 

<h4> <a name="viewing"></a>Viewing Sets</h4>

<p>The <b class="unixcommand">pr</b> command is the heart of viewing sets. In
   an interactive XPAT session, it lets you view the results you've searched
   for. Within the middleware, getting the data back from XPAT is the first step;
   next there is a
   small amount of manipulation of the XML that is returned from XPAT queries; finally
   conversion to HTML is done via <a href="../ui/index.html#XslStylesheets">XSLT
   stylesheets</a>. </p>


<dl> <dt> <tt class="unixcommand">pr (point-set)</tt></dt><dd> This prints out
the members of the point-set, starting with the first, according to the current <a href="#sortorder" class="unixcommand">{sortorder}</a> setting.</dd><dt> <tt class="unixcommand">pr.X
shift.-Y (point-set)</tt></dt><dd> Print the results in the point-set in a string
X bytes wide, offset to the left of the matching point Y bytes. X and Y overide
the <tt>settings</tt> of <tt>{printlength}</tt> and <tt>{leftcontext}</tt> respectively
(which are described <a href="#settings">below</a>).</dd><dt> <tt class="unixcommand">pr.region."region-name" (region-set
of type "region-name")</tt></dt><dd> prints the entire span of each the members
in the region set. It seems redundant to have to tell XPAT the "format" of the
region you would like to see, when it should already know!</dd><dt>&nbsp; </dt><dd>&nbsp;</dd><dt>In
interactive mode, the following prints the last set created.</dt><dt><tt class="unixcommand">pr</tt></dt><br>
<tt class="unixcommand">pr %</tt> <br>
<tt class="unixcommand">pr.X shift.-Y</tt> <dd>&nbsp; </dd></dl>
<p><b>Note</b>: The <span class="unixcommand">save</span> command is, in a sense,
   the same as the <span class="unixcommand">pr</span> command: <tt class="unixcommand">pr</tt> displays
   to STDOUT, <span class="unixcommand">save</span> outputs (appends) to a file
   whose name is given by <tt class="unixcommand">{savefile}</tt>. The format
   of the output is the same.</p>


<!-- #BeginLibraryItem "/Library/back to top.lbi" -->
<a href="#top"><i>Back to top</i></a> 
<!-- #EndLibraryItem --> 

<hr width="25%"> 

<h4> <a name="UsingOps"></a>Using the Operators to Make Sets of Interest</h4>

  <p>Using some basic XPAT operators, we can build some very specific searches that take advantage of the XML markup. Here is an actual example from the TextClass implementation. </p>

  <p>Consider this (edited) XML of a TEI header element and note the highlighted portion:
<blockquote><pre><tt>
  &lt;HEADER>
    &lt;FILEDESC>
      &lt;TITLESTMT>
        &lt;TITLE TYPE="245"> The Balkan Peninsula, / by Émile de Laveleye&lt;/TITLE>
        <b>&lt;AUTHOR> Laveleye, Emile de,  1822-1892. &lt;/AUTHOR></b>
      &lt;/TITLESTMT>
      &lt;PUBLICATIONSTMT>
        &lt;PUBLISHER>DLPS ...&lt;/PUBLISHER>
        &lt;IDNO TYPE="dlps">abe5413.0001.001&lt;/IDNO>
      &lt;/PUBLICATIONSTMT>
      &lt;SOURCEDESC>
        &lt;BIBLFULL>
          &lt;TITLESTMT>
            &lt;TITLE TYPE="main"> The Balkan Peninsula, / by Émile de Laveleye&lt;/TITLE>
            &lt;AUTHOR> Laveleye, Emile de,  1822-1892. &lt;/AUTHOR>
            &lt;AUTHOR> Thorpe, Mary,  Mrs.,  tr. &lt;/AUTHOR>
          &lt;/TITLESTMT>
          &lt;PUBLICATIONSTMT>
            &lt;PUBLISHER>G. P. Putnam's sons,&lt;/PUBLISHER>
          &lt;/PUBLICATIONSTMT>
        &lt;/BIBLFULL>
      &lt;/SOURCEDESC>
    &lt;/FILEDESC>
    &lt;ENCODINGDESC> ... &lt;/ENCODINGDESC>
    &lt;PROFILEDESC> ... &lt;/PROFILEDESC>
  &lt;/HEADER>
  </tt></pre></blockquote>

<p>The following query is actually the basis for the fabricated region called <b><i>mainauthor </i></b>in most of our text collections.</p>

<blockquote> <pre><code>>> <span class="unixcommand">((region AUTHOR within (region TITLESTMT within region FILEDESC)) not within (region SOURCEDESC))</span> 
6: 2 matches

>> <span class="unixcommand">pr.region.6</span>
   235, ..&lt;AUTHOR&gt; Yriarte, Charles, 1832-1898. &lt;/AUTHOR&gt; ..
513768, ..&lt;AUTHOR&gt; Laveleye, Emile de, 1822-1892. &lt;/AUTHOR&gt;.. </code></pre>
</blockquote>

                          <hr width="10%">

          <p>Let's say we want a slice of the the title(s) for the chapters in a given volume that contain hits for a users search for the word <b>prince</b>.   We construct the query in stages.</p>

          <ol>
            <li>Query to return a PSet consisting of hits on a user-entered search term:

<blockquote>
<pre><code> >> <span class="unixcommand">hitssearch = ("prince " + "prince&lt;")</span>
  1: hitssearch = one match</code></pre> 
</blockquote>
            </li>
            <li>Query for the DIV1 regions (chapters) that contain the hits:

<blockquote>
<pre><code> >> <span class="unixcommand">chapters = (region DIV1 incl (region "A-TYPE" incl "chapter")) incl *hitssearch</span>
  2: chapters = 14 matches</code></pre> 
</blockquote>
            </li>

            <li>Query for the regions contain HEAD elements that are not chapter heads:

<blockquote>
<pre><code> >> <span class="unixcommand">excludedheadregions = (region LIST) + (region FIGURE) + (region DIV2)</span>
  3: excludedheadregions = 25 matches</code></pre> 
</blockquote>
            </li>

            <li>Query for the HEAD elements in the DIV1 regions that contain the hits without the HEAD elements we don't want:

<blockquote>
<pre><code> >> <span class="unixcommand">chapterheads = (region HEAD within *chapters) not within *excludedheadregions</span>
  4: chapterheads = 14 matches</code></pre> 
</blockquote>
            </li>

            <li>Query for the particular volume we're interested in:

<blockquote>
<pre><code> >> <span class="unixcommand">volume = region main incl (region HEADER incl (region IDNO incl "abe5413.0001.001"))</span>
  5: volume = one match</code></pre> 
</blockquote>
            </li>

            <li>Query for the chapter heads just in that volume:

<blockquote>
<pre><code> >> <span class="unixcommand">volumechapterheads = *chapterheads within *volume</span>
  6: volumechapterheads = 11 matches</code></pre> 
</blockquote>
            </li>

            <li>Query for a slice of those chapter heads:

<blockquote>
<pre><code> >> <span class="unixcommand">volumechapterheadsslice = subset.1.5 *volumechapterheads</span>
  7: volumechapterheadsslice = 5 matches</code></pre> 
</blockquote>
            </li>

            <li>At last!  Print them out:

<blockquote>
<pre><code> >> <span class="unixcommand">pr.region.HEAD *volumechapterheadsslice</span>

   523428, ..&lt;HEAD>INTRODUCTORY  CHAPTER.&lt;LB/>THE PRESENT POSITION OF BULGARIAN AFFAIRS.&lt;/HEAD>..
   557986, ..&lt;HEAD>CHAPTER I.&lt;LB/>VIENNA—MINISTERS AND FEDERALISM.&lt;/HEAD>..
   600631, ..&lt;HEAD>CHAPTER II.&lt;LB/>BISHOP STROSSMAYER.&lt;/HEAD>..
   707081, ..&lt;HEAD>CHAPTER III.&lt;LB/>HISTORY AND RURAL ECONOMY OF BOSNIA.&lt;/HEAD>..
   819018, ..&lt;HEAD>CHAPTER IV.&lt;LB/>BOSNIA—ITS SOURCES OF WEALTH, ITS INHABITANTS, AND RECENT PROGRESS.&lt;/HEAD>..
</code></pre> 
</blockquote>
            </li>


          </ol>
       </p>

                            <!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back to top</i></a> <!-- #EndLibraryItem --> 

                        <hr width="50%"> 


   <h3><b><a name="fabricatedregions" id="fabricatedregions"></a>Introduction to fabricated regions</b> </h3>

   <p>A fabricated region is a "virtual" region that has been indexed. You can use any valid XPAT query to create a result set. Then, with the <span class="unixcommand">{export}</span> command, you can have XPAT create a binary index of the points in the result.</p>

   <p>There are two basic reasons to do this:

<ul>
<li>Searches are faster if dedicated indexes for complex queries are created offline and read into memory instead of being created in memory  repeatedly every time the middleware does a search.
<li>Fabricated regions provide a layer of abstraction so, for example, the middleware programmer can simply write code to ask for the  <tt><b>id</b></tt> region without having to handle many special cases of how the ID in documents in different collections might be marked up.  It could be marked up as <tt><b>&lt;IDNO TYPE="dlps">abc1234&lt;/IDNO></b></tt> or <tt><b>&lt;IDNO TYPE="notis">123456&lt;/IDNO></b></tt> or .... </li>
</ul> </p>

   <p>Once the fabricated regions are created and indexed, they can be searched for and printed just like any other region.</p>

   <p>We've actually already seen an example of a region that could be made into a a fabricated region in the last section.  Recall these two named regions:
<blockquote>
<pre><code> >> <span class="unixcommand">excludedheadregions = (region LIST) + (region FIGURE) + (region DIV2)</span>
  3: excludedheadregions = 25 matches</code></pre> 
</blockquote>

<blockquote>
<pre><code> >> <span class="unixcommand">chapterheads = (region HEAD within *chapters) not within *excludedheadregions</span>
  4: chapterheads = 14 matches</code></pre> 
</blockquote>

We could make the named query <tt><b>chapterheads</b></tt> into a fabricated region with the <span class="unixcommand">{export}</span> and <span class="unixcommand">{exportfile}</span> commands as follows:

<blockquote>
<pre><code><span class="unixcommand">{exportfile "/l1/idx/s/sample/chapterheads.rgn"}; export *chapterheads; ~sync "chapterheads";</span></code></pre></blockquote>

Another example of an important fabricated region in TextClass and FindaidClass is <tt><b>maindate</b></tt>.

<blockquote>
<pre><code>>> <span class="unixcommand">region maindate</span>
1: 2 matches

>> <span class="unixcommand">pr.region.maindate region maindate</span>
     1181, ..&lt;DATE>1876.&lt;/DATE>..
   514996, ..&lt;DATE>1887.&lt;/DATE>..
</code></pre></blockquote>

   <p> For more examples and discussion of fabricated regions, see: <a href="fabregions.html">Fabricated Regions</a>.</p>


                            <!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back to top</i></a> <!-- #EndLibraryItem --> 

                        <hr width="25%"> 


<h4> <a name="DebugQuery"></a>Debugging Complex Queries</h4>

  <p>The most likely queries you may need to debug are those involving fabregions because those will be queries you construct yourself as opposed to the hard-coded queries in the middleware.  Nonetheless, this technique is useful when debugging any involved query. </p>
    <p> The idea is simple.  Start XPAT at the command line and submit the sub-queries of the full query until you find one that does not return the result you expect.  To see the queries submitted to XPAT append <tt><b>;debug=search</b></tt> to the end of your URL and copy/paste the query strings into the XPAT command line prompt, submittting named queries before submitting queries that refer to the named queries.  Here's an example from the <a href="http://_______.ws.umdl.umich.edu/cgi/t/text/text-idx?c=sampletc_utf8;cc=sampletc_utf8;type=simple;rgn=full%20text;q1=dog;view=reslist;subview=detail;sort=title;start=1;size=25;didno=abe5413.0001.001;debug=search" target="external">sampletc_utf8 collection</a> </p>



<p><!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back to top</i></a> <!-- #EndLibraryItem --> </p>

<hr width="50%"> 

<h3><a name="additional"></a>Additional Details (not covered explicitly during the course of this workshop)</h3>

<p>For more information about all XPAT commands, <a href="http://www.dlxs.org/docs/13/xpat/index.html" target="external">see the regular DLXS documentation about XPAT</a>.</p>



<h4> <a name="settings"></a>{settings}</h4>

Settings control certain behaviors of XPAT during a search session. DLXS middleware explicitly uses the <tt class="unixcommand">{quieton}</tt> command. A full list of XPAT
commands, which includes the <span class="unixcommand">{ }</span> settings, can
be found at: <a href="http://quod.lib.umich.edu/sgml/pat/pat50manual.html" target="external">http://quod.lib.umich.edu/sgml/pat/pat50manual.html</a><br>
&nbsp; <dl> <dt> <tt class="unixcommand">{printlength #}</tt></dt><dd> This setting
controls the default print window size for point sets, how many total bytes are
given when a point set result is printed. See the discussion of <tt class="unixcommand">pr</tt> above.
Default is 64.</dd><dt> <tt class="unixcommand"><br>
{leftcontext #}</tt></dt><dd> This setting controls how many characters before
the matching text will be given when a point set is printed. If there are 100
characters of <tt class="unixcommand">{printlength}</tt>, and 14 of <tt class="unixcommand">{leftcontext}</tt>,
then the point where the matching text starts will be the 15th character. See
the discussion of <tt>pr</tt> above. Default is 14. <br>
&nbsp; </dd><dt> <tt><a name="sortorder"></a><span class="unixcommand">{sortorder &lt;order>}</span></tt></dt><dd>This
determines in what order a given set of results is sorted by XPAT. There are
other modes, but DLXS middleware always uses <tt class="unixcommand">{sortorder
occur}</tt>, which is to say that results are returned in the byte order in which
they occur in the source text.</dd><dt> <tt class="unixcommand"><br>
{savefile "file"}</tt></dt><dd> Changes the default save file name.</dd>When
the <span class="unixcommand">save</span> command is given, results are appended
to the file.<br>
&nbsp; <dt> <tt class="unixcommand">{exportfile "file"}</tt></dt><dd> Changes
the default export file name. When the <span class="unixcommand">export</span> command
is given, results are appended to the file.</dd></dl><!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back
to top</i></a> <!-- #EndLibraryItem --> <hr width="10%"> <h4 class="sectionheader"> Miscellaneous
and Useful Commands</h4><dl> <dt> <tt><a name="ddinfo"></a><span class="unixcommand">{ddinfo
regionnames}</span></tt></dt><dd> Lists all the currently-defined regions in
the <em>.idx</em>, <em>.rgn</em> and even fabricated region <em>.rgn</em> files.
A very useful command for document analysis</dd><br>
&nbsp; <dt> <tt><a name="history"></a><span class="unixcommand">history</span></tt></dt><dd> List
of results sets from previously issued searches and the commands that created
them. </dd><dt>&nbsp;</dt><dt><tt><a name="subset"></a><span class="unixcommand">subset.X.Y
A</span></tt></dt><dd> Make a new set that consists of Y members of A, starting
at the Xth member of A. Members of A start numbering at 1. <b>Note</b>: This
command is used in the middleware to get results in <i>slices</i>.</dd><dd>&nbsp;</dd><dt> <tt class="unixcommand">~sync "<i>string</i>"</tt></dt><dd> A
very useful command; basically an echo sort of command. This is used in the Middleware
to signal when XPAT is done sending results. In any of the <tt>{quieton}</tt> modes,
this returns:</dd><blockquote><tt>&lt;Sync><i>string</i>&lt;/Sync></tt></blockquote><!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back
to top</i></a> <!-- #EndLibraryItem --> 

<hr width="10%"> </dl>

<h4> <a name="Operators"></a><span class="sectionheader">Operators
and Relations</span></h4>These are the operators most used in the Middleware. <dl> <dt> <b><tt>A
^ B</tt></b></dt><dd> the "and" or "intersection" operator: A and B are two sets,
or expressions that evaluate to sets, and the resulting set includes those points
or regions <i>in both A and B that have the exact same start offsets</i>.</dd><dt> <b><tt>A
+ B + C + ...</tt></b></dt><dd> the "or" or "union" operator: A, B, C... are
sets. The resulting set (which is a point set if at least one of the sets being
combined is a point set), consisting of the start offsets of all the points or
regions in the original sets. If <i>all</i> the sets being combined are region
sets, then regions that nest inside other listed regions (either entirely or
at their start byte offset) will be removed from the resultant set.</dd><dt> <b><tt>A
incl B</tt></b></dt><br>
<b><tt>A not incl B</tt></b> <dd> A is a region set, B is either a point or region
set. The result is a region set of all members of A that contain at least one
member of B, containment meaning that a given B has a start offset within the
inclusive range of a given A's start and end offsets.</dd><dt> <b><tt>A within
B</tt></b></dt><br>
<b><tt>A not within B</tt></b> <dd> In many ways the complement to <span class="unixcommand">incl</span>:
A is a point or region set, B is a region set, the resulting set is all members
of A that are contained (by the start offset rule as under <span class="unixcommand">incl</span>)
in any B. This also takes the <span class="unixcommand">not</span> operator to
return all A's that are not within any B.</dd><dt> <b><tt>A near B</tt></b></dt><dd> A
and B are either points or regions. The result is all A's whose start offsets
are within # number of bytes of the start offset of any B (# is either explicitly
stated (with <span class="unixcommand">near.#</span>), or taken from the <tt class="unixcommand">{proximity}</tt> setting).
The <span class="unixcommand">not</span> form returns all A's whose start offsets
are not within the specified number of bytes from the start offset of any B.
The nearest B might be earlier or later in the source file.</dd><dt> <b><tt>A
fby B</tt></b></dt><dd> This is like the <span class="unixcommand">near</span> operator,
except that an A must be followed within the specified number of bytes by a B
to be in the result set. This can also takes the <span class="unixcommand">not</span> operator.</dd><dt> <b><tt>not</tt></b></dt><dd> This
reverses the sense of the expression it modifies, usable with <b class="unixcommand">incl</b>, <b class="unixcommand">within</b>, <b class="unixcommand">near</b>,
and <b class="unixcommand">fby</b>.</dd><dt>&nbsp;</dt><dt><!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back
to top</i></a> <!-- #EndLibraryItem --></dt></dl>
<hr width="10%"> </dl>

<h4> <a name="Operators"></a><span class="sectionheader">&#147;quieton raw&#148; mode</span></h4>

<p>The default mode, in an interactive XPAT session, is "quietoff". This gives
   the results messages you have seen so far: numbered sets, byte offsets followed
   by snippets of SGML with ".." on either end, etc. Another mode, and the most
   useful for interacting with XPAT programmatically, is "quieton raw". Nothing
   seems to happen when one enters:</p>
<blockquote>
<pre>&gt;&gt; <span class="unixcommand">{quieton&nbsp;raw}</span></pre>
</blockquote>
<p>However, entering queries now produces results that are tagged in a way that
   is easily parsable from within a program. First enter an earlier point search: </p>
<blockquote> <pre><code><span class="unixcommand">firstsearch&nbsp;=&nbsp;("Branivoj " + "Branivoj&lt;")</span><br>
&lt;SSize&gt;1&lt;/SSize&gt; <span class="unixcommand">pr</span><br>
&lt;PSet&gt;&lt;Start&gt;313615&lt;/Start&gt;&lt;Raw&gt;&lt;Size&gt;64&lt;/Size&gt;res
du nom de Branivoj s'emparent du territoire qu'ils gouvernen&lt;/Raw&gt;&lt;/PSet&gt; </code></pre></blockquote>
<p>Now enter an earlier region search:</p>
<blockquote> <pre><code><span class="unixcommand">((region AUTHOR within (region
TITLESTMT within region FILEDESC)) not within (region SOURCEDESC))</span> &lt;SSize&gt;4&lt;/SSize&gt; <span class="unixcommand">pr.region.AUTHOR</span><br>
&lt;RSet&gt;&lt;Start&gt;143&lt;/Start&gt;&lt;End&gt;178&lt;/End&gt;&lt;Raw&gt;&lt;Size&gt;36&lt;/Size&gt; &lt;AUTHOR&gt;Holbach,
Maude M. &lt;/AUTHOR&gt;&lt;/Raw&gt;&lt;Start&gt;298344&lt;/Start&gt; &lt;End&gt;298391&lt;/End&gt;&lt;Raw&gt;&lt;Size&gt;48&lt;/Size&gt;&lt;AUTHOR&gt;Yriarte,
Charles, 1832-1898. &lt;/AUTHOR&gt;&lt;/Raw&gt; &lt;Start&gt;792438&lt;/Start&gt;&lt;End&gt;792487&lt;/End&gt;&lt;Raw&gt;&lt;Size&gt;50&lt;/Size&gt; &lt;AUTHOR&gt;Laveleye,
Emile de, 1822-1892. &lt;/AUTHOR&gt;&lt;/Raw&gt;&lt;Start&gt;1689410&lt;/Start&gt; &lt;End&gt;1689486&lt;/End&gt;&lt;Raw&gt;&lt;Size&gt;77&lt;/Size&gt; &lt;AUTHOR&gt;Sebright,
Georgina Mary Muir (Mackenzie), Lady, d. 1874- &lt;/AUTHOR&gt;&lt;/Raw&gt;&lt;/RSet&gt;</code></pre></blockquote>
<p>Some of these tags are self-explanatory (e.g., SSize = set size). But some
   may need a bit of explanation. </p>
<dl> <dt>PSet</dt><dd>These tags surround an entire set of point results.</dd><dt>RSet</dt><dd>These
tags surround an entire set of region results.</dd><dt>Start</dt><dd>Byte offset
of beginning of one result, either point or region.</dd><dt>End</dt><dd>Byte
offset of end of one result, either point set string or region.</dd><dt>Raw</dt><dd>The "raw" information
of one particular result.</dd><dt>Size</dt><dd>Byte offset of end of one result,
either point set string or region.</dd><dt>text following the &lt;/Size&gt; tag</dt><dd>Actual
retrieved text of result.</dd></dl><!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back
to top</i></a> <!-- #EndLibraryItem --> 


<hr width="10%"> 

<h4><a name="programmingxpat"></a>Programming XPAT queries in Perl</h4>
<p>XPAT's ability to return results with tags allows a program to parse the results
   into pieces. In the DLXS Middleware this is done by a group of DLXS Perl modules.
   These modules have methods to let the CGI program interact with XPAT (an XPAT
   process is forked off by the CGI program and queries can be made of it at
   any time). The main object the code uses is the <b>xpat object</b>. It has
   methods for making queries in different ways and for interacting with the
   forked off XPAT process. </p>
<p>Here is some code (from TextClass.pm) that illustrates how the middleware
   uses a method of the Perl-based XPAT object (created in an earlier part of
   the code).</p>
<blockquote>
<pre><code>... my $query = qq{(region mainheader incl ( $idnorgn incl "$idno" ) );};
my ( $error, $result) = $xpat-&gt;GetSimpleResultsFromQuery( $query );
if ( $error )
{
     &amp;DlpsUtils::errorBail( qq{Query error in FindXPATContainingIdno: $result} );
}

&amp;DlpsUtils::StripAllRSetCruft( \$result );
$result =~ m,&lt;SSize&gt;(\d+)&lt;/SSize&gt;,;
my $hit = $1;
if ( $hit &gt; 0 )
{
    $returnXpat = $xpat; last;
}
... </code></pre></blockquote>
<p>While some code, such as this, makes a query via a simple method, most
   queries in the middleware are actually made by other means, through other
   objects and their methods. Once data has been prepared according to the DLXS
   Class DTDs, in terms of searching, the middleware can be thought of as an
   engine that simply "runs" the
   data.</p>
<!-- #BeginLibraryItem "/Library/back to top.lbi" --><a href="#top"><i>Back
to top</i></a> <!-- #EndLibraryItem -->
</body>
</html>
