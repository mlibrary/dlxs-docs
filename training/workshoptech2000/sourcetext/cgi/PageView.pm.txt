package PageView;use Exporter ();@ISA = qw( Exporter );use DlpsUtils qw( :DEFAULT );# pull in any configuration informationrequire "PageView.cfg";# **********************************************************************# this module is for PageView objects,## The structure of this object is:# PageView Object->#    {'currpageindex'}#    {'currabsseq'}#    {'currpagenumber'}#    {'curconfid'}#    {'featurepagetable'}#    {'thumbnails'}#    {'datfilelines'}## **********************************************************************# ----------------------------------------------------------------------# NAME      : new# PURPOSE   : create new PageView object# CALLED BY : # CALLS     : $self->_initialize# INPUT     : idno,  page sequence number# RETURNS   : NONE# NOTES     : # ----------------------------------------------------------------------sub new {    my $class = shift;    my $self = {};    bless $self, $class;    $self->_initialize(@_);    return $self;}# ----------------------------------------------------------------------# NAME      : _initialize# PURPOSE   : create structure for TextClass object# CALLED BY : new# CALLS     : # INPUT     : see new# RETURNS   : # NOTES     : # ----------------------------------------------------------------------sub _initialize {    my $self = shift;    my ( $idno, $baseObjDir ) = @_;
    # get pageview.dat file    my $path         = $self->ExpandIdnoToPath ( $idno, $baseObjdir );    my $pageViewFile = $baseObjDir . $path . $gPageViewDataFile;        $self->{'pageviewdatfile'} = $pageViewFile;            ## gather information from pageview.dat file, skipping comments and blank lines    ## while proceeding through file, create table of features    ## pageview.dat file is a tab delimited file that we are parsing brute force here    my ( $line, %pages );    my %currFeaturePageTable;    my ( $filename, $absSeq, $pageNum, $confid, $feature  );        # temporarily set input separator    my $incomingSeparator = $/;    $/ = "\n";        open (PAGEVIEW, "<$pageViewFile") ||      &errorBail (qq{Could not open $pageViewFile for reading: $!});    while ( $line = <PAGEVIEW> )     {	next   if ( $line =~ m,^\#, );	next   if ( $line =~ m,^\s*$, );	chomp ($line);	( $filename, $absSeq, $pageNum, $confid, $feature  ) = split ( /\t/, $line );        ## add page info to has indexed by page sequence number        # remove leading zeroes        $absSeq     =~ s,^0+,,;        $pageNum =~ s,^0+,,;        $pages{$absSeq}{'seq'} = $absSeq;        $pages{$absSeq}{'filename'} =  $filename;        $pages{$absSeq}{'pagenum'} = $pageNum;        $pages{$absSeq}{'confid'} = $confid;        $pages{$absSeq}{'feature'} = $feature;        	## add to table (%currFeaturePageTable) the first occurrences of a feature	## ***** always create a feature for the first page        if ( $absSeq == 1 )        {    $currFeaturePageTable{'1stpg'} = $filename;	}        ## if not the first page, add only the first occurrence of the particular feature        elsif ($gPageFeatureTableTypes{$feature} && !$currFeaturePageTable{$feature})         {    $currFeaturePageTable{$feature} = $filename;   }    }    close (PAGEVIEW);    # reset input separator    $/ = $incomingSeparator;    ## save the last (highest) seq number as the seq of the last page    $self->{'lastpageseq'}  = $absSeq;    $self->{'featuretable'} = \%currFeaturePageTable;    $self->{'pageinfo'}     = \%pages;    $self->{'defaultview'} = $gDefaultView;    $self->{'defaultsize'} = $gDefaultSize;    $self->{'defaultseq'}  = $gDefaultSeq;        $self->{'sizehash'} = \%gSizes;    $self->{'viewhash'} = \%gViews;#    $self->{'viewlist'} = \@gViews;    $self->{'pagefeaturetypes'} = \%gPageFeatureTypes;    $self->{'fullobjdir'} = $baseObjDir . $path;}# ----------------------------------------------------------------------# NAME         : ExpandIdnoToPath# PURPOSE      : # CALLED BY    : _initialize# CALLS        : # INPUT        : string which is idno# RETURNS      : full path to the dir that contains this idno's files# GLOBALS      : # SIDE-EFFECTS : # NOTES        : # ----------------------------------------------------------------------sub ExpandIdnoToPath{    my $self = shift;    my ( $idno, $baseObjDir ) = @_;    $idno = lc($idno);    my ( $path );    if ( $idno =~ m,^([a-z])([a-z])([a-z]).*, )    {        $path = '/' . join ( '/', $1, $2, $3, $idno ) . '/';    }    else    {        &errorBail(qq{Could not match Idno $idno to sgml file path.});    }     return $path;}# ----------------------------------------------------------------------# NAME         : # PURPOSE      : #                # CALLED BY    : # CALLS        : # INPUT        : # RETURNS      : # GLOBALS      : # SIDE-EFFECTS : # NOTES        : # ----------------------------------------------------------------------sub GetLastPageSeq{    my $self = shift;        return $self->{'lastpageseq'};}# ----------------------------------------------------------------------# NAME         : # PURPOSE      : #                # CALLED BY    : # CALLS        : # INPUT        : # RETURNS      : # GLOBALS      : # SIDE-EFFECTS : # NOTES        : # ----------------------------------------------------------------------sub GetPageInfoBySeqAndKey{    my $self = shift;    my ( $seq, $key ) = @_;        return $self->{'pageinfo'}{ $seq }{ $key };}# ----------------------------------------------------------------------# NAME         : # PURPOSE      : #                # CALLED BY    : # CALLS        : # INPUT        : # RETURNS      : # GLOBALS      : # SIDE-EFFECTS : # NOTES        : # ----------------------------------------------------------------------sub GetFeaturePageTable{    my $self = shift;        return $self->{'featuretable'};}# ----------------------------------------------------------------------# NAME         : # PURPOSE      : #                # CALLED BY    : # CALLS        : # INPUT        : # RETURNS      : # GLOBALS      : # SIDE-EFFECTS : # NOTES        : # ----------------------------------------------------------------------sub GetPageviewDataFile{    my $self = shift;        return $self->{'pageviewdatfile'};}sub GetSizesHash{    my $self = shift;    my $hashRef = $self->{'sizehash'};    return %{$hashRef} ;}sub GetViewsHash{    my $self = shift;    my $hashRef = $self->{'viewhash'};    return %{$hashRef} ;}sub GetDefaultView{    my $self = shift;    return $self->{'defaultview'};}sub GetDefaultSize{    my $self = shift;    return $self->{'defaultsize'};}sub GetDefaultSeq{    my $self = shift;    return $self->{'defaultseq'};}sub GetPageInfo{    my $self = shift;    my %pageInfoHash = % { $self->{'pageinfo'} };    my %pageLabelsHash;        # run through sequence numbers in order    # could use index itself except I wonder if there might exist the    # situation where some pages were not scanned so index and sequence number     # are not as related as we might want    my @seqsArray = sort { $a <=> $b } ( keys %pageInfoHash );    my $i;    for ( $i=0; $i<=$#seqsArray; $i++ )    {        my $pageNum = $pageInfoHash{ $seqsArray[$i] }{ 'pagenum' } || 'NA';        my $feature = $pageInfoHash{ $seqsArray[$i] }{ 'feature' };        if ( ( $feature eq 'UNS' ) ||              ( ! defined( $feature ) ) )        {  $pageLabelsHash{ $seqsArray[$i] } = $pageNum ;     }        else        { $pageLabelsHash{ $seqsArray[$i] } = $pageNum . ' : ' . $self->GetPageFeatureLabel( $feature );  }    }        return ( \@seqsArray, \%pageLabelsHash );}sub GetPageFeatureLabel{    my $self = shift;    my $key  = shift;        my $featureHashRef = $self->{'pagefeaturetypes'};    return $$featureHashRef{ $key };    }# ----------------------------------------------------------------------# NAME         : CreateGifFile# PURPOSE      : #                # CALLED BY    : # CALLS        : # INPUT        : self, directory where to leave created gif file# RETURNS      : name of gif file created# GLOBALS      : # SIDE-EFFECTS : # NOTES        : uses tif2gif and info in self to create a gif file#                and deposit it in the proper directory# ----------------------------------------------------------------------sub CreateGifFile{    my $self = shift;    my ( $idno, $seq, $view, $size, $gifConvertDir ) = @_;        my $tiffFileName = $self->GetPageInfoBySeqAndKey( $seq, 'filename'  );    my $sizeCode = $size;    ## ***** construct file name for cached gif file *****    my $gifFileName = $gifConvertDir . $idno . '/' . $tiffFileName . $sizeCode . '.gif' ;    my $gifDestDir  = $gifConvertDir . $idno . '/';    # now that we've used the simple tif file name, create full path to tif file    $tiffFileName = $self->GetFullObjDirPath( ) . $tiffFileName;        if ( $ENV{'DEBUG'} )    {   print "GifDestDir: $gifDestDir<br>\n";    }                   ## ***** create sub dir in which to deposit gif file *****    if (! -e $gifDestDir )    {    `$gMakeDirExecutable -m 2775 -p $gifDestDir 2>> $gMakeDirOutputLog`;   }    # Longest we'll wait for GIF to be ready    local($locktime) = 8;    while ( -e "$gifFileName.lock" && $locktime > 0 )    { 	$locktime--; 	sleep 1;    }    my(@gifstat);    if ( ! -e "$gifFileName" ||	(@gifstat=stat("$gifFileName"))[9] < (stat($tiffFileName))[9]	|| $gifstat[7] == 0 )  {	my $command =           qq{$gTIF2GIF -N $gNumGrey -g $gGamma -$sizeCode -o $gifFileName $tiffFileName};        if ( $gDebug )        {   print "Command: $command<br>\n";   }	`$command 2>> $gMakeDirOutputLog`;    }    # strip off directory so we can return just the name#    $gifFileName =~ s,$gifDestDir,/,;    if ( $ENV{'DEBUG'} )    {   print "HERE:<br>$gifFileName<br>\n";   }    return $gifFileName;}# ----------------------------------------------------------------------# NAME         : CreatePdfFile# PURPOSE      : #                # CALLED BY    : # CALLS        : # INPUT        : # RETURNS      : # GLOBALS      : # SIDE-EFFECTS : # NOTES        : # ----------------------------------------------------------------------sub CreatePdfFile{    my $self = shift;    my ( $idno, $seq, $view, $size, $pdfConvertDir ) = @_;    my $tiffFileName = $self->GetPageInfoBySeqAndKey( $seq, 'filename'  );    ## ***** construct file name for cached gif file *****    my $pdfFileName = $pdfConvertDir . $idno . '/' . $tiffFileName .'.pdf' ;    my $pdfDestDir  = $pdfConvertDir . $idno . '/';    # now that we've used the simple tif file name, create full path to tif file    $tiffFileName = $self->GetFullObjDirPath( ) . $tiffFileName;        if ( ! -e "$pdfFileName" ||         (@pdfstat=stat("$pdfFileName"))[9] < (stat($tiffFileName))[9]         || $pdfstat[7] == 0 )      {#        `touch /tmp/foo`;                ## ***** check to see if directory path exists *****        if (! -e $pdfDestDir )        {    `$gMakeDirExecutable -m 2775 -p $pdfDestDir 2>> $gMakeDirOutputLog`;   }        my $urlsString = qq{file://$tiffFileName\n};         my $tempUrlListFile = '/tmp/' . "$$";                ## ***** we definitely need the newline for the printps command *****        &PrintStringToFile ( $urlsString , $tempUrlListFile );        my $command = qq{$gPrintps $tempUrlListFile | $gDistiller > $pdfFileName};                `$command 2>> $gMakeDirOutputLog`;                unlink ($tempUrlListFile);    }            return     $pdfFileName ;}# ----------------------------------------------------------------------# NAME         : GetFullObjDirPath# PURPOSE      : #                # CALLED BY    : # CALLS        : # INPUT        : # RETURNS      : # GLOBALS      : # SIDE-EFFECTS : # NOTES        : # ----------------------------------------------------------------------sub GetFullObjDirPath{    my $self = shift;        return $self->{'fullobjdir'};}## ----------------------------------------------------------------------1;        ÿ